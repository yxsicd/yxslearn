package main

import (
	"database/sql"
	"fmt"
	"log"
	"net/http"
	"path"
	"strings"
	"sync"
	"time"

	_ "github.com/mattn/go-sqlite3"
)

func main() {
	// initdb("ttt.db")
	initHttp()
}

var dbmap = make(map[string]*sql.DB)
var dblock sync.RWMutex

func getDB(dbname string) *sql.DB {
	dblock.RLock()
	db, ok := dbmap[dbname]
	dblock.RUnlock()
	if ok {
		return db
	} else {
		dblock.Lock()
		newdb := initdb(dbname)
		dbmap[dbname] = newdb
		dblock.Unlock()
		return newdb
	}

}

func initdb(dbname string) *sql.DB {
	// basepath := "/dev/shm"
	basepath := "./target/"
	dbpath := path.Join(basepath, dbname)
	// os.Remove(dbpath)
	db, err := sql.Open("sqlite3", dbpath+"?cache=shared&mode=rwc")
	if err != nil {
		log.Print(err)
	}
	db.Exec("PRAGMA journal_mode=WAL;")
	return db
}

func ExecDBSql(dbname string, sql string) (sql.Result, error) {
	return getDB(dbname).Exec(sql)
}

func QueryDBSql(dbname string, sql string) (*sql.Rows, error) {
	return getDB(dbname).Query(sql)
}

func initHttp() {
	mux := http.NewServeMux()
	mux.HandleFunc("/", func(w http.ResponseWriter, req *http.Request) {
		begin_time := time.Now()
		qv := req.URL.Query()
		dbname := qv.Get("db")
		sqlstring := qv.Get("sql")

		if dbname == "" || sqlstring == "" {
			return
		}

		if strings.HasPrefix(strings.ToLower(strings.TrimSpace(sqlstring)), "select") {
			rows, err := QueryDBSql(dbname, sqlstring)
			if err != nil {
				fmt.Fprintf(w, "%s", err)
				return
			}

			columns, err := rows.Columns()
			if err != nil {
				fmt.Fprintf(w, "%s", err)
				return
			}
			column_count := len(columns)
			for rows.Next() {
				value_list := make([]interface{}, 0)
				for j := 0; j < column_count; j++ {
					var v string
					value_list = append(value_list, &v)
				}
				err = rows.Scan(value_list...)
				if err != nil {
					log.Fatal(err)
				}
				for _, v := range value_list {

					vs, ok := v.(*string)
					if ok {
						fmt.Fprintf(w, "%s,", *vs)
					}
				}
				fmt.Fprintf(w, "\n")
			}
			log.Printf("use time is %v", time.Since(begin_time))
			return
		} else {
			_, err := ExecDBSql(dbname, sqlstring)
			if err != nil {
				fmt.Fprintf(w, "%s", err)
			}
		}

	})
	http.ListenAndServe(":8080", mux)
}
